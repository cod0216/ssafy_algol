# [Silver I] 유성 - 10703 

[문제 링크](https://www.acmicpc.net/problem/10703) 

### 분류

구현

### 문제 설명

<p>작고 특이한 모양의 유성 사진이 인터넷에 올라왔다. 사진에는 매우 높은 곳에서 떨어지고 있는 유성이 허공에 찍혀 있었다. 유성이 떨어지고 난 뒤의 사진도 있었지만 안타깝게도 소실돼버려 이를 복원해야 한다.</p>

<p>유성 사진을 문자의 배열로 단순화시켜 표기할 것이다. 문자 'X'는 유성의 일부를, 문자 '#'는 땅의 일부를, 그리고 나머지(공기)는 문자 '.'로 이루어져 있다.</p>

<p>모든 유성 조각들은 연결되어 있다. 즉, 두 부분 유성이 존재한다면, 한 쪽에서 유성 조각을 통해 상하좌우로 이동해서 다른 부분 유성에 도달할 수 있다. 땅 또한 같은 방식으로 연결되어 있다.</p>

<p>주어진 사진에서 유성은 땅보다 위에 있다. 정확히 말하자면, 적어도 한 줄 이상의 공기('.')가 존재하며, 유성은 그 보다 위에, 땅은 그 보다 아래쪽에 있다. 또한, 사진의 맨 밑 줄은 모두 땅이다.</p>

<p>유성은 수직으로 낙하한다. 유성이 땅에 떨어졌을 때, 유성과 땅은 원형을 유지한다고 한다. 유성이 떨어진 후의 사진을 복구하여라.</p>

### 입력 

 <p>첫 번째 줄에는 각각 사진의 세로와 가로 길이를 의미하는 정수 R과 S (3 ≤ R, S ≤ 3 000)가 주어진다.</p>

<p>다음 R 개의 줄에는 문자로 단순화된 사진이 주어진다.</p>

### 출력 

 <p>유성이 떨어지고 난 뒤의 사진(크기 R × S)을 복원하여 출력하라.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

public class Main {
    static int N, M, pMap[][], lMap[][], gapArr[], cnt[], lGap[], minGap = Integer.MAX_VALUE;
    public static void main(String[] args) throws IOException {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        String[] input = buffer.readLine().split(" ");
        N = Integer.parseInt(input[0]);
        M = Integer.parseInt(input[1]);

        pMap = new int[N][M];
        lMap = new int[N][M];
        gapArr = new int[M];
        cnt = new int[M];
        lGap = new int[M];
        
        // 0 : air
        // 1 : planet
        // 2 : land
        for(int i = 0 ; i <  N; i++){
            String line = buffer.readLine();
            for(int j = 0 ; j <  M; j++){
                char value = line.charAt(j);
                if(value == 'X') pMap[i][j] = 1;
                else if (value == '#') lMap[i][j] = 2;
            }
        }
        
        for(int i = 0 ; i <  M; i++){
-            int pGap = 0;
+            int pGap = -1;
            int land = N;
            for(int j = 0 ; j <  N; j++){
                if(pMap[j][i] == 1){
                    cnt[i]++;
                    pGap = j;
                }
                if(lMap[j][i] == 2 && land == N) land = j;

            }
            if(pGap != -1 && land != N) {
                gapArr[i] = land - pGap -1;
                minGap = Math.min(minGap, gapArr[i]);
            }
        }
        
        for(int i = 0 ; i < N; i++) {
            for(int j = 0 ; j < M; j++) {
                if(pMap[i][j] == 1) lMap[i+minGap][j] = 1;
            }
        }
        
        for(int i = 0 ; i < N; i++) {
            for(int j = 0 ; j < M; j++) {
                char value;
                if(lMap[i][j] == 2) value = '#';
                else if (lMap[i][j] == 1) value = 'X';
                else value = '.';
                sb.append(value);
            }    
            sb.append("\n");
        }
        System.out.println(sb);
        
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

처음에 시간초과가 났는데 생각해보니 split(" ")을 이용하고 거기에 또 arrToChar()를 이용하니까 두번 엉뚱한 연산을 하게 됐다. 이걸 line으로 받고 charAt으로 푸니까 시간 초과는 넘겼는데 유성이 없는 경우를 고려하지 않아서 답이 틀렸다고 나왔다 초기 값을 -1로 줘서 해결할 수 있었다. 실버 주제어 어려웠다. 