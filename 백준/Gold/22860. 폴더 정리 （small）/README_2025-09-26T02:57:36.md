# [Gold III] 폴더 정리 (small) - 22860 

[문제 링크](https://www.acmicpc.net/problem/22860) 

### 분류

자료 구조, 깊이 우선 탐색, 그래프 이론, 그래프 탐색, 해시를 사용한 집합과 맵, 문자열, 트리, 집합과 맵

### 문제 설명

<p>이름이 <code>main</code> 폴더 안에 여러가지 파일과 폴더가 존재한다.</p>

<pre>main
 ├─ FolderA
 │    ├─ File1
 │    └─ File2
 └─ FolderB
       ├─ FolderC
       ├─ File1
       └─ File3</pre>

<p>위 구조는 <code>main</code> 폴더의 하위 구조를 계층적으로 표시한 것이다. <code>FolderA</code>, <code>FolderB</code>, <code>FolderC</code>는 폴더이고 <code>File1</code>, <code>File2</code>, <code>File3</code>은 파일이다. 파일 이름이 같은 경우는 동일한 파일이다.</p>

<p>한 폴더 안에는 같은 이름의 파일이 두 개 이상 존재할 수 없다.</p>

<p><code>main</code> 하위 디렉토리에 같은 이름의 폴더가 두 개 이상 존재할 수 없다.</p>

<p>폴더 정리를 하기 위해 <code>main</code> 폴더 하위에 있는 파일들을 확인하려고 한다.</p>

<p>주어지는 쿼리에 대해 폴더와 파일의 정보를 알려주는 프로그램을 만들어보자.</p>

### 입력 

 <p>첫 번째 줄에는 <code>main</code> 폴더 하위에 있는 폴더의 총 개수 $N$과 파일의 총 개수 $M$이 공백으로 구분되어 주어진다.</p>

<p>두 번째 줄부터 $N + M + 1$ 번째까지 상위 폴더의 이름 $P$, 폴더 또는 파일의 이름 $F$, 폴더인지 아닌지 알려주는 $C$가 공백으로 구분되어 주어진다.</p>

<p>$C$의 값은 $F$가 폴더라면 1, 파일이라면 0으로 주어진다.</p>

<p>$N + M + 2$ 번째 줄에는 쿼리의 개수 $Q$가 주어진다.</p>

<p>그 다음줄부터 $Q$개의 쿼리가 주어진다. 쿼리마다 <code>main</code>부터 폴더의 경로 정보가 들어온다. 예를 들어 <code>main</code> 폴더 안에 <code>FolderB</code>에 대한 쿼리가 들어온다면, <code>FolderB</code>의 경로인 <code><q>main/FolderB</q></code>로 주어진다. 반드시 폴더가 존재하는 경로로 주어짐을 보장한다.</p>

### 출력 

 <p>쿼리 순서대로 한 줄씩 폴더 하위에 있는 파일의 종류의 개수와 파일의 총 개수를 출력한다.</p>

<p>파일의 종류의 개수는 같은 파일이 여러개 있을 경우 하나로 계산한다. 파일의 총 개수는 같은 파일이 있더라도 하나로 계산하지 않는다.</p>

<p>예를 들어 이름이 <code>File1</code> 파일이 5개가 있을 경우 파일의 종류는 1 가지이고 파일의 총 개수는 5개이다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

class Folder {
    Map<String, Folder> sub = new HashMap<>();
    List<String> files = new ArrayList<>();    
}


public class Main {
    static int N, M;
    static Map<String, Folder> dir = new HashMap<>();    
    public static void main(String[] args) throws IOException {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        
        String[] input = buffer.readLine().split(" ");
        N = Integer.parseInt(input[0]);
        M = Integer.parseInt(input[1]);
        
        dir. put("main",new Folder());
        
        for(int i = 0; i < N + M; i++){
            input = buffer.readLine().split(" ");
            String parent = input[0];
            String name = input[1];
            int type = Integer.parseInt(input[2]);
            
            Folder p;
            if(dir.containsKey(parent)) p = dir.get(parent);
            else {
                p = new Folder();
                dir.put(parent, p);
            }
            
            if( type == 1) {
                Folder child;
                if(dir.containsKey(name)) child = dir.get(name);
                else {
                    child = new Folder();
                    dir.put(name, child);
                }
                p.sub.put(name,child);
            } else {
                p.files.add(name);
            }
        }
        
        int Q = Integer.parseInt(buffer.readLine());
        StringBuilder sb = new StringBuilder();
        for(int q = 0; q < Q; q++){
            String line = buffer.readLine();
            String[] path = line.split("/");
            
            Folder cur = dir.get("main");
            for(int i = 1; i< path.length; i++) {
                if (cur == null) break;
                cur = cur.sub.get(path[i]);
            }
            
            if(cur == null){
                sb.append("0 0");
                sb.append("\n");
                continue;
            }
            HashSet<String> kinds = new HashSet<String>();
            int total = dfs(cur, kinds);
            sb.append(kinds.size());
            sb.append(' ');
            sb.append(total);
            sb.append('\n');
        }    
        System.out.print(sb);
    }
    
    static public int dfs(Folder n, HashSet<String> kinds) {
        int cnt = 0;
        
        for(int i = 0; i< n.files.size(); i++){
            kinds.add(n.files.get(i));
            cnt++;
        }
        for(Map.Entry<String, Folder> e : n.sub.entrySet()){
            cnt += dfs(e.getValue(), kinds);
        }
        return cnt;
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

Map 자료구조 사용하는게 다른 자료구조들 보다 더 어렵게 느껴진다. 능숙함이 차이 아닌까 싶다.