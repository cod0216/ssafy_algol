# [Gold III] 다리 만들기 - 2146 

[문제 링크](https://www.acmicpc.net/problem/2146) 

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색, 격자 그래프

### 문제 설명

<p>여러 섬으로 이루어진 나라가 있다. 이 나라의 대통령은 섬을 잇는 다리를 만들겠다는 공약으로 인기몰이를 해 당선될 수 있었다. 하지만 막상 대통령에 취임하자, 다리를 놓는다는 것이 아깝다는 생각을 하게 되었다. 그래서 그는, 생색내는 식으로 한 섬과 다른 섬을 잇는 다리 하나만을 만들기로 하였고, 그 또한 다리를 가장 짧게 하여 돈을 아끼려 하였다.</p>

<p>이 나라는 N×N크기의 이차원 평면상에 존재한다. 이 나라는 여러 섬으로 이루어져 있으며, 섬이란 동서남북으로 육지가 붙어있는 덩어리를 말한다. 다음은 세 개의 섬으로 이루어진 나라의 지도이다.</p>

<p style="text-align: center;"><img alt="" height="225" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/JudgeOnline/upload/201008/bri.PNG" width="243"></p>

<p>위의 그림에서 색이 있는 부분이 육지이고, 색이 없는 부분이 바다이다. 이 바다에 가장 짧은 다리를 놓아 두 대륙을 연결하고자 한다. 가장 짧은 다리란, 다리가 격자에서 차지하는 칸의 수가 가장 작은 다리를 말한다. 다음 그림에서 두 대륙을 연결하는 다리를 볼 수 있다.</p>

<p style="text-align: center;"><img alt="" height="220" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/JudgeOnline/upload/201008/b2.PNG" width="247"></p>

<p>물론 위의 방법 외에도 다리를 놓는 방법이 여러 가지 있으나, 위의 경우가 놓는 다리의 길이가 3으로 가장 짧다(물론 길이가 3인 다른 다리를 놓을 수 있는 방법도 몇 가지 있다).</p>

<p>지도가 주어질 때, 가장 짧은 다리 하나를 놓아 두 대륙을 연결하는 방법을 찾으시오.</p>

### 입력 

 <p>첫 줄에는 지도의 크기 N(100이하의 자연수)가 주어진다. 그 다음 N줄에는 N개의 숫자가 빈칸을 사이에 두고 주어지며, 0은 바다, 1은 육지를 나타낸다. 항상 두 개 이상의 섬이 있는 데이터만 입력으로 주어진다.</p>

### 출력 

 <p>첫째 줄에 가장 짧은 다리의 길이를 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

public class Main {
    static int N, ans= Integer.MAX_VALUE;
    static int[] dx = new int[]{1, 0, -1, 0};
    static int[] dy = new int[]{0, 1, 0, -1};
    static int[][] map;
    static boolean[][] visited;
    public static void main(String[] args) throws IOException {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(buffer.readLine());
        map = new int[N][N];
        visited = new boolean[N][N];
        
        // input
        for(int i = 0 ; i < N; i++){
            String[] input = buffer.readLine().split(" ");
            for(int j = 0 ; j < N; j++){
                map[i][j] = Integer.parseInt(input[j]);
            }
        }
        
        // transition
        int cnt = 1;
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                if(visited[i][j] || map[i][j] == 0) continue;
                bfs(i, j, cnt);
                cnt++;
            }
        }  

        // do
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                if(map[i][j] == 0) continue;
                makeBrige(i,j);
            }        
        }
        
        System.out.println(ans);      
    }
    public static void makeBrige(int a, int b){    
        Queue<int[]> queue = new ArrayDeque<>();
        visited = new boolean[N][N];

        queue.offer(new int[]{a, b, 0});     
        visited[a][b] = true;
        int mapNumber = map[a][b];
        
        while(!queue.isEmpty()){
            int[] dir = queue.poll();
            int nx = dir[0];
            int ny = dir[1];
            int nc = dir[2];
            
            for(int i = 0 ; i < 4; i++){
                int tx = nx+dx[i];
                int ty = ny+dy[i];
                if(isIn(tx,ty) && map[tx][ty] != mapNumber && map[tx][ty] != 0){
                    ans = Math.min(ans, nc);
                    return;
                }
                if(isIn(tx,ty) && !visited[tx][ty] && map[tx][ty] == 0){
-                    visited[nx][ny] = true;
+                    visited[tx][ty] = true;
                    queue.offer(new int[]{tx, ty, nc+1});
                }
            }
            
        } // queue while end
    }    
    
    public static void bfs(int a, int b, int cnt){
        Queue<int[]> queue = new ArrayDeque<>();
        queue.offer(new int[]{a, b});
        visited[a][b] = true;
        map[a][b] = cnt;
        
        while(!queue.isEmpty()){
            int[] dir = queue.poll();
            int nx = dir[0];
            int ny = dir[1];
            
            for(int i = 0 ; i < 4; i++){
                int tx = nx+dx[i];
                int ty = ny+dy[i];
                if(isIn(tx,ty) && !visited[tx][ty] && map[tx][ty] != 0){
                    visited[tx][ty] = true;
                    queue.offer(new int[]{tx,ty});
                    map[tx][ty] = cnt;
                }
            }
        } // queue while end
    }
    
    public static boolean isIn(int x, int y){
        return x >=0 && y >= 0 && x < N && y < N;
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

오랜만에 풀었는데 다리 만드는 부분에서 많이 헷갈렸습니다. 섬의 가장 자리를 어떻게 해야 할까 고민하다가 엄청 복잡하게 구현하게 되었습니다. 실제 map을 찍어 보니 의도치 않는 값들이 찍혔고 전에 풀었던 코드를 참고했습니다.
가장자리 나 경계값은 생각보다 단순했고 상하좌우 탐색 시 `0`이면 가장 자리로 인식하는 방식이였습니다.
그리고 메모리 초과 문제가 발생했는데 잘못된 풀이 방식에서 `visited[nx][ny]`를 삽입했던 코드를 수정하지 못해 발생했습니다. 메모리 문제가 발생했던 경우들을 생각해 보면 반복문 안에서 인스턴스를 생성하거나 visited배열을 이용한 경우가 대다수였던것 같습니다. 메모리 초과 발생시 이 두 부분을 먼저 확인하면 좋을 것 같습니다.