# [Gold II] 성냥개비 - 3687 

[문제 링크](https://www.acmicpc.net/problem/3687) 

### 분류

다이나믹 프로그래밍, 그리디 알고리즘

### 문제 설명

<p>성냥개비는 숫자를 나타내기에 아주 이상적인 도구이다. 보통 십진수를 성냥개비로 표현하는 방법은 다음과 같다.</p>

<p><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/upload/images/match.png" style="height:88px; width:607px"></p>

<p>성냥개비의 개수가 주어졌을 때, 성냥개비를 모두 사용해서 만들 수 있는 가장 작은 수와 큰 수를 찾는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스는 최대 100개 이다. 각 테스트 케이스는 한 줄로 이루어져 있고, 성냥개비의 개수 n이 주어진다. (2 ≤ n ≤ 100)</p>

### 출력 

 <p>각 테스트 케이스에 대해서 입력으로 주어진 성냥개비를 모두 사용해서 만들 수 있는 가장 작은 수와 가장 큰 수를 출력한다. 두 숫자는 모두 양수이어야 하고, 숫자는 0으로 시작할 수 없다. </p>



#  🚀  오답노트 

```diff
import java.io.*;
import java.util.*;

public class Main {
-    static final int INF = Integer.MAX_VALUE;
-    static int[] num = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
+    static final long INF = Long.MAX_VALUE / 10;
+    static final int[] match = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6};
+    static long[] min = new long[101];
+    static String[] max = new String[101];
+    static final int[] usable = {1, 7, 4, 2, 0, 8};
+
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(br.readLine());
        StringBuilder sb = new StringBuilder();
-        int N = 100;
-        
-        int[] min = new int[N+1];
-        int[] max = new int[N+1];

-        for(int i=1 ; i <= N ; i++){
-            min[i] = INF;
-            for(int j=0 ; j <= 9 ; j++){
-                if(i - num[j] >= 0){
-                    max[i] = Math.max(max[i], max[i - num[j]]*10 + j);
-                    if(min[i - num[j]] != INF && min[i - num[j]]*10 + j > 0){
-                        min[i] = Math.min(min[i], min[i - num[j]]*10 + j);
-                    }
-                }
+        Arrays.fill(min, INF);
+        calculateMin();
+        calculateMax();
+
+        while (T-- > 0) {
+            int n = Integer.parseInt(br.readLine());
+            sb.append(min[n]).append(" ").append(max[n]).append("\n");
+        }
+
+        System.out.print(sb);
+    }
+
+    static void calculateMin() {
+        min[2] = 1;
+        min[3] = 7;
+        min[4] = 4;
+        min[5] = 2;
+        min[6] = 6;
+        min[7] = 8;
+        min[8] = 10;
+
+        for (int i = 9; i <= 100; i++) {
+            for (int j = 2; j <= 7; j++) {
+                if (min[i - j] == INF) continue;
+                long cand = min[i - j] * 10 + usable[j - 2];
+                if (cand < min[i]) min[i] = cand;
            }
        }
-        
-        while(T-- > 0){
-            int n = Integer.parseInt(br.readLine());
-            sb.append(min[n])
-              .append(" ")
-              .append(max[n])
-              .append("\n");
-        }// end tc
-        
-        System.out.println(sb);
-    }// end main
+    }
+
+    static void calculateMax() {
+        max[2] = "1";
+        max[3] = "7";
+        for (int i = 4; i <= 100; i++) {
+            if (i % 2 == 1) {
+                max[i] = "7" + max[i - 3];
+            } else {
+                max[i] = max[i - 2] + "1";
+            }
+        }
+    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

점화식 방향성은 금방 구했는데 이중 for문 하나로 처리하다가 너무 오래걸렸다