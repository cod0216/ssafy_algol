# [Gold III] 소수의 연속합 - 1644 

[문제 링크](https://www.acmicpc.net/problem/1644) 

### 분류

수학, 정수론, 두 포인터, 소수 판정, 에라토스테네스의 체

### 문제 설명

<p>하나 이상의 연속된 소수의 합으로 나타낼 수 있는 자연수들이 있다. 몇 가지 자연수의 예를 들어 보면 다음과 같다.</p>

<ul>
	<li>3 : 3 (한 가지)</li>
	<li>41 : 2+3+5+7+11+13 = 11+13+17 = 41 (세 가지)</li>
	<li>53 : 5+7+11+13+17 = 53 (두 가지)</li>
</ul>

<p>하지만 연속된 소수의 합으로 나타낼 수 없는 자연수들도 있는데, 20이 그 예이다. 7+13을 계산하면 20이 되기는 하나 7과 13이 연속이 아니기에 적합한 표현이 아니다. 또한 한 소수는 반드시 한 번만 덧셈에 사용될 수 있기 때문에, 3+5+5+7과 같은 표현도 적합하지 않다.</p>

<p>자연수가 주어졌을 때, 이 자연수를 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 자연수 N이 주어진다. (1 ≤ N ≤ 4,000,000)</p>

### 출력 

 <p>첫째 줄에 자연수 N을 연속된 소수의 합으로 나타낼 수 있는 경우의 수를 출력한다.</p>



#  🚀  오답노트 

```diff
import java.io.*;
import java.util.*;

public class Main {
    static int N, answer = 0;
    static long prefix[];
    static boolean[] isNotSosu;
    static List<Integer> list;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());
        isNotSosu = new boolean[N+1];
        list = new ArrayList<>();
        
        findSosu();
        getPrefix();
        getCount();
        
        //System.out.println(list);
        //System.out.println(Arrays.toString(prefix));

        System.out.println(answer);
    }//end main
    
    private static void getCount(){
        int length = prefix.length;
        
        for(int left = 0 ; left < length ; left++){
            int idx = Arrays.binarySearch(prefix, left + 1, length, prefix[left] + N);
            if(idx >= 0) answer++;
        }
    }
    
    private static void getPrefix(){
        prefix = new long[list.size() + 1];
        for(int i=1 ; i <= list.size() ; i++){
            prefix[i] = prefix[i-1] + list.get(i-1);
        }
    }
    
    private static void findSosu(){
        isNotSosu[1] = true;

        for(int i=2 ; i <= N ; i++){
            if(isNotSosu[i]) continue;
            list.add(i);
            for(int j=2; j <= N ; j++){
                if(i*j > N) break;
                isNotSosu[i*j] = true;
            }
        }
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

