# [Gold I] 트리 뒤집기 - 33873 

[문제 링크](https://www.acmicpc.net/problem/33873) 

### 분류

다이나믹 프로그래밍, 트리, 트리에서의 다이나믹 프로그래밍

### 문제 설명

<p>$N$개의 노드를 가진 루트가 $1$인 트리가 있다. 트리의 각 노드에 앞면과 뒷면에 모두 수가 쓰여있는 카드가 놓여있다.</p>

<p>송이는 이 트리에 다음과 같은 행동을 원하는 만큼 할 수 있다.</p>

<ul>
	<li>트리의 노드를 하나 선택한다.</li>
	<li>선택한 노드를 루트로 하는 서브 트리의 카드들을 선택한 노드를 포함해 모두 뒤집는다.</li>
</ul>

<p>송이는 카드의 앞면에 적힌 $N$개의 수의 합을 최대화하려고 한다.</p>

<p>이때 앞면에 적힌 $N$개의 수의 합의 최댓값과 뒤집는 행동을 최소 몇 번 해야 하는지 구해보자.</p>

### 입력 

 <p>첫째 줄에 노드의 개수 $N$이 주어진다. $(2 \leq N \leq 100\,000)$</p>

<p>둘째 줄에 노드 $i$에 놓인 카드의 앞면에 적힌 수 $F_i$가 공백으로 구분되어 주어진다. $(1 \leq i \leq N; -1\,000 \leq F_i \leq 1\,000)$</p>

<p>셋째 줄에 노드 $i$에 놓인 카드의 뒷면에 적힌 수 $B_i$가 공백으로 구분되어 주어진다. $(1 \leq i \leq N; -1\,000 \leq B_i \leq 1\,000)$</p>

<p>넷째 줄부터 $N - 1$줄에 걸쳐 트리 간선의 양 끝점 $u, v$가 공백으로 구분되어 주어진다. $(1 \leq u, v \leq N$; $u \ne v)$</p>

<p>입력으로 주어지는 수는 모두 정수이다.</p>

### 출력 

 <p>앞면의 합의 최댓값과 뒤집어야 하는 최소 횟수를 공백으로 구분하여 출력한다.</p>



#  🚀  오답노트 

```diff
import java.io.*;
import java.util.*;

public class Main {
    static final int INF = 1_000_000_000;
    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        int[] F = new int[N], B = new int[N];
        
        String[] s = br.readLine().split(" ");
        for(int i=0;i<N;i++) F[i] = Integer.parseInt(s[i]);
        
        s = br.readLine().split(" ");
        for(int i=0;i<N;i++) B[i] = Integer.parseInt(s[i]);

        List<Integer>[] g = new ArrayList[N];
        for(int i=0;i<N;i++) g[i] = new ArrayList<>();
        for(int i=0;i<N-1;i++){
            s = br.readLine().split(" ");
            int a = Integer.parseInt(s[0])-1;
            int b = Integer.parseInt(s[1])-1;
            g[a].add(b); g[b].add(a);
        }
        
        long total = 0;
        for(int i=0;i<N;i++) total += Math.max(F[i], B[i]);

        int[] parent = new int[N];
        Arrays.fill(parent, -1);
        
        int[] order = new int[N];
        int p = 0, q = 0;
        
        order[q++] = 0; parent[0] = 0;

        while(p < q){
            int v = order[p++];
            for(int nx : g[v]) if(parent[nx] == -1){
                parent[nx] = v;
                order[q++] = nx;
            }
        }

        int[][] dp = new int[N][2];
        for(int i=0;i<N;i++) dp[i][0]=dp[i][1]=INF;

        for(int i=N-1;i>=0;i--){
            int v = order[i];
            for(int s0=0;s0<2;s0++){
                boolean allow = 
                    (F[v]>B[v] ? s0==0 :
                    (F[v]<B[v] ? s0==1 : true));
                if(!allow) continue;

                int cost = 0;
                for(int nx : g[v]){
                    if(nx == parent[v]) continue;
                    int best = INF;
                    for(int s1=0;s1<2;s1++){
                        if(dp[nx][s1] == INF) continue;
                        best = Math.min(best, dp[nx][s1] + (s1!=s0?1:0));
                    }
                    cost += best;
                }
                dp[v][s0] = cost;
            }
        }

        long ans = Math.min(dp[0][0], dp[0][1] + 1L);
        System.out.println(total + " " + ans);
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

트리 DP 나오니까 정신을 못차리겠네