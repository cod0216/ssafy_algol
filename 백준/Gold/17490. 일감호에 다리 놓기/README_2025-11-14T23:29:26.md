# [Gold III] 일감호에 다리 놓기 - 17490 

[문제 링크](https://www.acmicpc.net/problem/17490) 

### 분류

자료 구조, 분리 집합, 그래프 이론, 그리디 알고리즘, 최소 스패닝 트리

### 문제 설명

<p>학교의 홍보대사를 맡게 된 건덕이는 건국대학교의 모든 강의동을 신입생들에게 소개해야 한다.</p>

<p>건국대학교 중앙에 위치한 일감호를 따라 한 바퀴를 돌며 모든 강의동을 소개하는 것이 그의 일이지만, 몇몇 구간들이 공사 중이어서 그 구간을 통해서는 갈 수 없는 상황이다. 급한대로 건덕이는 호수에 돌을 던져 징검다리를 놓아 길을 만들어보려고 한다.</p>

<p>강의동은 일감호의 둘레에 따라 원형으로 배치돼 있으며, 강의동 양 옆의 강의동은 서로 이웃한다. 또, 원형으로 배치돼 있기 때문에 <em>N</em>개의 강의동이 있다면 <em>N</em>번째 강의동과 1번째 강의동은 서로 이웃한다.</p>

<p>일감호 안에는 와우도라는 섬이 있다. 건덕이는 한 강의실에서 다른 모든 강의실로 이동할 수 있도록 강의동에서 와우도까지 징검다리를 놓기로 했다. 하지만 건덕이의 눈에는 <em>K</em>개의 돌밖에 보이지 않는다. 건덕이는 주어진 돌을 활용해서 징검다리를 완성할 수 있을까?</p>

### 입력 

 <p>첫째 줄에 강의동의 수 <em>N</em>, 공사구간의 수 <em>M</em>, 건덕이가 가진 돌의 수 <em>K</em>가 공백으로 구분돼 주어진다. 강의동은 1동부터 N동까지 존재한다.</p>

<p>다음 줄에는 강의동에서 와우도까지 놓아야하는 돌의 개수 S<sub>1</sub>, S<sub>2</sub>, ..., S<sub>N</sub>이 공백으로 구분돼 주어진다. 이는 <em>T</em>번째 강의동에서 와우도까지 S<sub>T</sub>개의 돌을 놓아야 함을 의미한다. 이어서 <em>M</em>개의 줄에 i, j가 주어진다. 이는 i번째 강의동에서 j번째 강의동까지 가는 길이 공사중임을 의미한다. 이 때 입력되는 i, j번째 건물은 이웃한 강의동이다. 공사중인 구역은 한 번만 주어진다.</p>

### 출력 

 <p>건덕이가 가지고 있는 돌을 놓아 모든 강의동을 연결할 수 있으면 <code>YES</code>를, 그렇지 않으면 <code>NO</code>를 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

public class Main {
    static int N, M, p[], s[];
    static long R, ans;
    static LinkedList<Integer> check[];
    static boolean visited[];
    public static void main(String[] args) throws IOException{
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        String[] input = buffer.readLine().split(" ");
        N = Integer.parseInt(input[0]);
        M = Integer.parseInt(input[1]);
        R = Long.parseLong(input[2]); 
        
        if (M <= 1) {
            System.out.println("YES");
            return;
        }
        
        s = new int[N+1];
        p = new int[N+1];
        input = buffer.readLine().split(" ");
        check  = new LinkedList[N+1];
        visited = new boolean[N+1];
        
        for(int i = 1 ; i <= N; i++){
            check[i] = new LinkedList<>();
        }
        
        for(int i = 1 ; i <= N; i++){
            s[i] = Integer.parseInt(input[i-1]);
            p[i] = i;
        }
        for(int i = 0 ; i < M; i++){        
            input = buffer.readLine().split(" ");            
            int a = Integer.parseInt(input[0]);
            int b = Integer.parseInt(input[1]);
            
            int max = Math.max(a,b);
            int min = Math.min(a,b);            
            check[max].add(min);
            
        }
        
        for (int i = 1; i < N; i++) {
            int a = i;
            int b = i + 1;
            int max = Math.max(a, b);
            int min = Math.min(a, b);

            if (!check[max].contains(min)) {
                union(a, b);
            }
        }
        
        {
            int a = N;
            int b = 1;
            int max = Math.max(a, b); // N
            int min = Math.min(a, b); // 1
            if (!check[max].contains(min)) {
                union(a, b);
            }
        }

        
        long[] minCost = new long[N+1];
        Arrays.fill(minCost, Long.MAX_VALUE);

        for (int i = 1; i <= N; i++) {
            int root = find(i);
            if (s[i] < minCost[root]) {
                minCost[root] = s[i];
            }
        }

        ans = 0L;
        Arrays.fill(visited, false);
        for (int i = 1; i <= N; i++) {
            int root = find(i);
            if (!visited[root]) {
                visited[root] = true;
                ans += minCost[root];
            }
        }
        
        System.out.println(ans <= R ? "YES" : "NO");
    }
    
    public static int find(int n){
        if(p[n] != n) return p[n] = find(p[n]);
        return n;
    }
    
    public static boolean union(int a, int b){
        int max = Math.max(find(a), find(b));
        int min = Math.min(find(a), find(b));
        p[max] = min;
        return true;
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

