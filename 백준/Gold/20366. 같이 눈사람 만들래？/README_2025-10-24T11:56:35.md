# [Gold III] 같이 눈사람 만들래? - 20366 

[문제 링크](https://www.acmicpc.net/problem/20366) 

### 분류

정렬, 두 포인터

### 문제 설명

<blockquote>
<p>언니! 똑...똑똑...똑똑! 같이 눈사람 만들래~? ♪</p>
</blockquote>

<p>언니 엘자와 동생 안나에게는 <em>N</em>개의 눈덩이가 있다. 각 눈덩이 <em>i</em> (1 ≤ <em>i</em> ≤ <em>N</em>)의 지름은 <em>H<sub>i</sub></em> 이다. 하나의 눈사람은 두 개의 눈덩이로 구성되며, 눈덩이 하나를 아래에 두고 그 눈덩이보다 크지 않은 다른 눈덩이를 쌓아올리는 방식으로 만들 수 있다. 이때, 눈사람의 키는 두 눈덩이 지름의 합과 같다.</p>

<p>엘자와 안나는 눈덩이 <em>N</em>개 중 서로 다른 4개를 골라서 눈사람을 각각 1개씩, 총 2개를 만들려고 한다. 두 자매는 두 눈사람의 키의 차이가 작을수록 두 눈사람의 사이가 좋을 것이라고 믿는다. 우리는 엘자와 안나가 가장 사이좋은 두 눈사람을 만들기 위해서 도와주려고 한다.</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/65c871bd-cf26-4fd7-bda6-91728bbaf742/-/preview/" style="height: 277px; width: 400px;"></p>

<p>주어진 <em>N</em>개의 눈덩이를 이용하여 만들 수 있는 두 눈사람의 키 차이 중 최솟값을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 <em>N</em> (4 ≤ <em>N</em> ≤ 600)이 주어진다.</p>

<p>둘째 줄에는 각 눈덩이 <em>i</em> (1 ≤ <em>i</em> ≤ <em>N</em>)의 지름을 의미하는 정수 <em>H<sub>i</sub></em> (1 ≤ <em>H<sub>i</sub></em> ≤ 10<sup><span style="font-size: 10.8333px;">9</span></sup>)가 공백으로 구분되어 주어진다.</p>

### 출력 

 <p>만들 수 있는 두 눈사람의 키 차이 중 최솟값을 나타내는 정수를 출력하라.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(buffer.readLine());
        int[] arr = new int[N];
        
        int min = Integer.MAX_VALUE;
        
        String[] input = buffer.readLine().split(" ");
        
        for(int i = 0 ; i < N; i++){
            arr[i] = Integer.parseInt(input[i]);
        }
        
        Arrays.sort(arr);
        
        int index = 0;
        
        for(int i  = 0 ; i < N-1; i++){
            for(int j  = i+1 ; j < N; j++){            
                int target = arr[i] + arr[j];
                
                int start = 0;
                int end = N-1;
                while(start < end){
                  if(start == i || start == j ){
                    start++;
                    continue;
                  } 
                  if(end == i || end == j ) {
                    end--;
                    continue;
                  }
                  
                  int sum = arr[start] + arr[end];
                  int diff = Math.abs(target - sum);
                  
                  if(diff < min){
                      min = diff;
                      if(min == 0){
                        System.out.println(min);
                        return;
                      }
                  }
                  
                  if(sum < target){
                    start++;
                  }else end--;
                }
            }
        }
        
        System.out.println(min);
        
        
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

인덱스를 사용한 것들을 체크 해야 되는데 이걸 클래스로 만들었는데 어떻게 해도 시간 복잡도가 N^4 가 나오는 것 같았다. 생각해보니 투포인터는 N이니까 N^3으로 마무리 할 수 있었다. DFS도 생각해봤는데 그럼 2^600이여서 ㄴㄴ 했다. 눈사람 뿌셔버리고 싶다. 권해림도 뿌셔버리고 싶다.