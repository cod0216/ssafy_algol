# [Gold V] 토마토 - 7569 

[문제 링크](https://www.acmicpc.net/problem/7569) 

### 분류

너비 우선 탐색, 그래프 이론, 그래프 탐색, 격자 그래프, 최단 경로

### 문제 설명

<p>철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.</p>

<p style="text-align: center;"><img alt="" src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.comhttps://u.acmicpc.net/c3f3343d-c291-40a9-9fe3-59f792a8cae9/Screen%20Shot%202021-06-22%20at%202.49.11%20PM.png" style="width: 201px; height: 252px;"></p>

<p>창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.</p>

<p>토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.</p>

### 입력 

 <p>첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.</p>

<p>토마토가 하나 이상 있는 경우만 입력으로 주어진다.</p>

### 출력 

 <p>여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.</p>



#  🚀  오답노트 

```diff
-import java.util.*;
-import java.io.*;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.LinkedList;
+import java.util.StringTokenizer;

+/**
+ * 3차원 배열,
+ * 익은토마토의 상하좌우 위아래 연쇄
+ * 토마토가 모두 익을때까지 걸리는 기간?
+ * 
+ * 시간초과가 나서 고민해봤더니 익은 토마토는 한 번만 검사하면 된다는 걸 간과
+ */
+
public class Main {
-    
-    static int[] dx = {1,-1,0,0,0,0};
-    static int[] dy = {0,0,1,-1,0,0};
-    static int[] dz = {0,0,0,0,1,-1};
-    static int N, M, H, box[][][];
-    
-    public static void main(String[] args) throws Exception {
-        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-        StringTokenizer st = new StringTokenizer(br.readLine());
-        
-        N = Integer.parseInt(st.nextToken());
-        M = Integer.parseInt(st.nextToken());
-        H = Integer.parseInt(st.nextToken());
-        
-        box = new int[N][M][H];
-        boolean visited[][][] = new boolean[N][M][H];

-        Deque<int[]> tomato = new ArrayDeque<>();
-        int allTomato = 0;
-        int completeTomato = 0;
-        for(int z=0; z < H ; z++){
-            for(int y=0; y < M ; y++){
-                st = new StringTokenizer(br.readLine());
-                for(int x=0; x < N ; x++){
-                    int temp = Integer.parseInt(st.nextToken());
-                    box[x][y][z] = temp;
-                    if(temp == 1){
-                        tomato.offer(new int[]{x,y,z});
-                        visited[x][y][z] = true;
-                        completeTomato++;
+	static int N, M, H, size, checkedSize, box[][][];
+	static int [] dr = {0,1,0,-1,0,0};
+	static int [] dc = {-1,0,1,0,0,0};//상하좌우위아래
+	static int [] dh = {0,0,0,0,1,-1};
+	
+	public static void main(String[] args) throws Exception {
+		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+		StringTokenizer st = new StringTokenizer(br.readLine());
+		M = Integer.parseInt(st.nextToken());//가로
+		N = Integer.parseInt(st.nextToken());//세로
+		H = Integer.parseInt(st.nextToken());
+		Deque<int[]> tomatos = new LinkedList<>();
+		Deque<int[]> nextTomatos = new LinkedList<>();
+		
+		box = new int[H][N][M];
+		size = 0;
+		checkedSize = 0;
+		for(int h=0 ; h < H ; h++) {			
+			for(int i=0 ; i < N ; i++) {	
+				st = new StringTokenizer(br.readLine());
+				for(int j=0 ; j < M ; j++) {
+					int temp = Integer.parseInt(st.nextToken());
+					box[h][i][j] = temp;
+					if(temp == 1) {
+						tomatos.add(new int[] {h,i,j});
+						size++;
+					}else if(temp == 0){
+                        size++;
                    }
-                    if(temp != -1) allTomato++;
-                }
-            }
-        }
-        
-        if(allTomato == tomato.size()){
-            System.out.println(0);
-            return;
-        }
-        
-        int day = -1;
-        while(!tomato.isEmpty()){
-            int size = tomato.size();
-            day++;
+				}
+			}
+		}
+		int day = 0;
+		//System.out.println(size);
+		if(size != tomatos.size()) {
+			while(!tomatos.isEmpty()) {	
+				while(!tomatos.isEmpty()) {
+					checkedSize++;
+					int[] tomato = tomatos.poll();
+					for(int d=0 ; d < 6 ; d++) {
+						int nh = tomato[0]+dh[d];
+						int nr = tomato[1]+dr[d];
+						int nc = tomato[2]+dc[d];
+						
+						//익지않은토마토 발견
+						if(isIn(nh,nr,nc) && box[nh][nr][nc] == 0) {
+							box[nh][nr][nc] = 1;
+							nextTomatos.add(new int[] {nh,nr,nc});
+						}
+					}
+				}
+		
+				if(nextTomatos.isEmpty() && checkedSize < size) {
+					day = 0;
+					break;
+				}
+				
+				
+				while(!nextTomatos.isEmpty()) {
+					tomatos.add(nextTomatos.poll());
+				}
+				
+				day++;

-            for(int s = 0 ; s < size ; s++){
-                int current[] = tomato.poll();
-                
-                for(int d=0 ; d < 6 ; d++){
-                    int nx = current[0] + dx[d];
-                    int ny = current[1] + dy[d];
-                    int nz = current[2] + dz[d];
-                    
-                    if(!isIn(nx,ny,nz) || visited[nx][ny][nz] || box[nx][ny][nz] != 0) continue;
-                    visited[nx][ny][nz] = true;
-                    tomato.offer(new int[]{nx,ny,nz});
-                    box[nx][ny][nz] = 1;
-                    completeTomato++;
-                    
-                }
-            }
-        }
-        
-        System.out.println(completeTomato == allTomato ? day : -1);
+			}//end while true
+			
+			System.out.println(day-1);
+		}else {
+			System.out.println(0);
+		}
+		
+		
+	}
+	
+	

-    }
-    
-    private static boolean isIn(int x, int y, int z){
-        return 0 <= x && x < N && 0 <= y && y < M && 0 <= z && z < H;
-    }
+	/**
+	 * 배열 범위 체크 메소드
+	 */
+	public static boolean isIn(int h, int r, int c) {
+		if(0 <= r && r < N && 0 <= c && c < M && 0 <= h && h < H) return true;
+		return false;
+	}
+	
+
+
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

