# [Gold III] 개구리 점프 - 17619 

[문제 링크](https://www.acmicpc.net/problem/17619) 

### 분류

자료 구조, 정렬, 스위핑, 분리 집합

### 문제 설명

<p>통나무 N개가 가로 (수평) 방향으로 연못에 떠 있다. 개구리는 한 통나무 A에서 다른 통나무 B로 정확히 수직 방향으로 점프할 수 있다. 단, 점프할 때 다른 통나무 위를 (끝 점 포함) 지나면 안된다.</p>

<p>예를 들어 <그림 1>에서 1번 통나무에서 2번 통나무로 점선을 따라 개구리가 점프하는 것이 가능하다. 1번 통나무에서 2번 통나무로 점프한 후 다시 3번 통나무로 점프하면 1번 통나무에서 3번 통나무로 이동하는 것이 가능하다. (통나무 위에서 걸어서 움직이는 것은 언제든 가능하다.)</p>

<p style="text-align: center;"><img alt="" src="https://upload.acmicpc.net/98a76e73-0187-43bb-90f9-435f8055e74f/-/preview/" style="width: 521px; height: 186px;"></p>

<p style="text-align: center;"><그림 1></p>

<p>통나무들의 위치를 입력받아 질문으로 주어진 통나무들의 쌍에 대해서 개구리가 한 통나무에서 다른 통나무로 한번 이상의 점프로 이동이 가능한지 판단하는 프로그램을 작성하라.</p>

### 입력 

 <p>첫 번째 줄에 통나무 개수 N과 질문의 개수 Q가 주어진다. 다음 N개의 줄에 각 통나무에 x<sub>1</sub>, x<sub>2</sub>, y의 세 정수 좌표가 주어진다. 주어진 통나무는 두 점 (x<sub>1</sub>, y)와 (x<sub>2</sub>, y)를 잇는 형태이다. (x<sub>1</sub> < x<sub>2</sub>) 모든 좌표는 0이상 10<sup>9</sup>이하이다. 통나무들은 주어진 순서대로 1번부터 번호가 붙어 있다. 서로 다른 두 통나무는 (끝점에서도) 만나지 않는다. 다음 Q개의 줄에 서로 다른 두 통나무의 번호가 주어진다. (1 ≤ N ≤ 100,000, 1 ≤ Q ≤ 100,000)</p>

### 출력 

 <p>Q개의 줄을 출력한다. 각 줄에는 주어진 순서대로 질문에 대한 대답이 출력되어야 한다. 질문에 주어진 두 통나무에 대해서 개구리가 한 통나무에서 다른 통나무로 한번 이상의 점프로 이동이 가능한 경우 대답은 1, 그렇지 않은 경우 대답은 0이다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

class Info implements Comparable<Info>{
    int start;
    int end;
    int n;
    
    public Info(int start, int end, int n){
        this.start = start;
        this.end = end;
        this.n = n;
    }
    public int compareTo(Info o){
        if(this.start == o.start) return o.end - this.end;
        return this.start - o.start;
    }
}

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        String[] input = buffer.readLine().split(" ");
        int N = Integer.parseInt(input[0]);
        int M = Integer.parseInt(input[1]);
        
        int[] yes = new int[N+1];
        PriorityQueue<Info> queue = new PriorityQueue<>();
        
        for(int i = 0; i < N; i++){
            input = buffer.readLine().split(" ");
            int s = Integer.parseInt(input[0]);
            int e = Integer.parseInt(input[1]);
            int n = i+1;
            
            queue.offer(new Info(s,e,n));
        }
        
        Info cur = queue.poll();
        int start = cur.start;
        int end = cur.end;
        int n = cur.n;
        yes[n] = n;
        
        while(!queue.isEmpty()){
            Info now = queue.poll();
            int s = now.start;
            int e = now.end;
            
            
-            if(s <= end && e > end){
-                end = e;
+            if(s <= end){
                yes[now.n] = n;
-            }else if(s > end){
+                if(e > end) end = e;
+            }else {
                start = s;
                end = e;
                n = now.n;
                yes[n] = n;
            }
        }
        for(int i = 0 ; i < M; i++){
            input = buffer.readLine().split(" ");
            int s = Integer.parseInt(input[0]);
            int e = Integer.parseInt(input[1]);
            
            System.out.println((yes[s] == yes[e] ? "1" : "0"));
            
        }
        
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

처음엔 2차원 배열로 했는데 메모리 초과가 났다. 근데 1차원 배열로 수정했는데 약간 union 느낌도 나고 이렇게 풀수도 있다는게 재밌다.