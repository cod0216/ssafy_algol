# [Gold II] 합이 0인 네 정수 - 7453 

[문제 링크](https://www.acmicpc.net/problem/7453) 

### 분류

정렬, 이분 탐색, 두 포인터, 중간에서 만나기

### 문제 설명

<p>정수로 이루어진 크기가 같은 배열 A, B, C, D가 있다.</p>

<p>A[a], B[b], C[c], D[d]의 합이 0인 (a, b, c, d) 쌍의 개수를 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>첫째 줄에 배열의 크기 n (1 ≤ n ≤ 4000)이 주어진다. 다음 n개 줄에는 A, B, C, D에 포함되는 정수가 공백으로 구분되어져서 주어진다. 배열에 들어있는 정수의 절댓값은 최대 2<sup>28</sup>이다.</p>

### 출력 

 <p>합이 0이 되는 쌍의 개수를 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(buffer.readLine());
        
        int[][] map = new int[N][4];
        
        for(int i = 0; i< N; i++){
            String[] input = buffer.readLine().split(" ");            
            for(int j = 0; j < 4; j++){
                map[i][j] = Integer.parseInt(input[j]);
            }
        }
        
        int[] AB = new int[N*N];
        int[] CD = new int[N*N];
        int index = 0;
        for(int i = 0; i < N; i++){
            for(int j = 0; j < N; j++){
                AB[index] = map[i][0] + map[j][1];
                CD[index] = map[i][2] + map[j][3];
                index++;
            }
        }
        
        Arrays.sort(CD);     
        
        
        long cnt  = 0;
        
        for(int i = 0; i < N*N; i++){
            int up = upperBound(CD, -AB[i]);
            int down = lowerBound(CD, -AB[i]);
            cnt += (up-down);
        }
        
        System.out.println(cnt);
        
    }
    
    public static int upperBound(int[] A, int target){
        int start = 0;
        int end = A.length;
        int mid = 0;
        while(start < end){
            mid = (start+end) / 2;
            if(A[mid] <= target){
                start = mid +1;
            } else {
                end = mid;
            }
        }
        
-        return start;
+        return end;
    }
    
    public static int lowerBound(int[] A, int target){
        int start = 0;
        int end = A.length;
        int mid = 0;
        while(start < end){
            mid = (start+end) / 2;
            if(A[mid] < target){
                start = mid +1;
            } else {
                end = mid;
            }
        }
        
-        return start;
+        return end;
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

