# [Gold IV] 모두싸인 출근길 - 24229 

[문제 링크](https://www.acmicpc.net/problem/24229) 

### 분류

그리디 알고리즘, 스위핑

### 문제 설명

<p>취준생 주헌이는 드디어 취업에 성공했다. 주헌이가 취직한 회사는 <strong>비대면 전자계약 서비스 모두싸인(MODUSIGN) </strong>이라는 회사이다. 그리고 오늘은 첫 출근날이다. 주헌이의 출근길에는 다리가 있는데, 전날에 비가 많이 오는 바람에 다리가 끊어져 판자 여러 개로 쪼개져 버렸다. 주헌이는 무사히 회사에 도착할 수 있을까?</p>

<p>다리는 수직선으로 나타낼 수 있으며, 각 판자는 구간 [ $L$, $R$ ]의 범위에 놓여 있다. 주헌이는 0에서 출발하여 오른쪽(양의 방향)으로만 이동한다. 판자로 덮인 좌표는 자유롭게 건너갈 수 있다. 하지만 판자로 덮이지 않은 좌표는 오직 주헌이가 <strong>점프</strong>를 해야만 건너갈 수 있으며, 점프를 할 경우 착지한 위치에 판자가 놓여 있어야 한다. 판자의 양 끝점에도 착지가 가능하다. 주헌이가 한 번의 점프로 건너갈 수 있는 최대 거리는 마지막으로 착지한 시점 이후로 건너간 거리와 같다. 단, 점프를 한 적이 없으면 출발한 시점 이후로 건너간 거리와 같다. 예를 들어 주헌이가 점프를 해서 좌표 9에 착지했고 12에서 다시 점프를 한다면, 점프할 수 있는 거리는 최대 3이다.</p>

<p>주헌이가 이동할 수 있는 가장 먼 지점을 구해보자. 단, 점프를 했는데 판자 위에 착지하지 못한 경우는 이동하지 않은 것으로 간주한다.</p>

### 입력 

 <p>첫째 줄에 판자의 개수 $N$<em> </em>이 주어진다. $( 1 ≤ N ≤ 200,000 )$</p>

<p>둘째 줄부터 $N$개의 줄에 걸쳐서 판자가 놓인 구간을 나타내는 정수 $L,R$<em> </em>이 각각 주어진다. $( 0 ≤ L < R ≤ 10^9 )$</p>

<p>$L = 0$인 판자가 적어도 하나는 주어진다.   </p>

### 출력 

 <p>주헌이가 최대로 멀리 이동할 수 있는 지점의 좌표를 출력한다.</p>



#  🚀  오답노트 

```diff
import java.util.*;
import java.io.*;

class Info implements Comparable<Info>{
    int s;
    int e;
    
    public Info(int s, int e){
        this.s = s;
        this.e = e;
    }
    
    public int compareTo(Info o){
        if(this.s == o.s) return o.e - this.e;
        return this.s - o.s;
    }
    
}

public class Main {
    public static void main(String[] args) throws IOException{
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(buffer.readLine());
        
        PriorityQueue<Info> queue = new PriorityQueue<>();
            
        for(int i = 0; i < N; i++){
            String[] input = buffer.readLine().split(" ");
            int s = Integer.parseInt(input[0]);
            int e = Integer.parseInt(input[1]);
            
            queue.offer(new Info(s,e));
        }

        ArrayList<Info> list = new ArrayList<>();
        Info cur = queue.poll();
        int s = cur.s;
        int e = cur.e;
        
        while(!queue.isEmpty()){
            
            Info next = queue.poll();
            if(next.s <= e){
                e = Math.max(next.e ,e);
            } else {
                list.add(new Info(s,e));
                s = next.s; e = next.e;
            }
        }
        list.add(new Info(s,e));
        
        
        int start = list.get(0).s;
        int end = list.get(0).e;
        long diff = Math.abs(start-end);
        long ans = end;
        int i = 0;
        while (true) {
            long reach = end + diff;
            int j = i + 1;
            if (j >= list.size() || list.get(j).s > reach) break;

            int bestIdx = -1;
            long bestScore = Long.MIN_VALUE;
            int k = j;
            while (k < list.size() && list.get(k).s <= reach) {
                int ns = list.get(k).s;
                int ne = list.get(k).e;
                long score = 2L * ne - ns;
                if (score > bestScore) {
                    bestScore = score;
                    bestIdx = k;
                }
                k++;
            }

            int ns = list.get(bestIdx).s;
            int ne = list.get(bestIdx).e;
            ans = ne;
            start = ns;
            end   = ne;
            diff  = Math.abs(ne - ns);
            i = bestIdx;
        }      
        
        System.out.println(ans);
    }
}

```

# 💻 코드 리뷰




 ## 🏆 메모 

아 이거 기존 문제들이랑 비슷한데 뭔가 디지게 어렵니 