# [Gold IV] ì—°êµ¬ì†Œ - 14502 

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/14502) 

### ë¶„ë¥˜

êµ¬í˜„, ê·¸ë˜í”„ ì´ë¡ , ë¸Œë£¨íŠ¸í¬ìŠ¤ ì•Œê³ ë¦¬ì¦˜, ê·¸ë˜í”„ íƒìƒ‰, ë„ˆë¹„ ìš°ì„  íƒìƒ‰, ê²©ì ê·¸ë˜í”„

### ë¬¸ì œ ì„¤ëª…

<p>ì¸ì²´ì— ì¹˜ëª…ì ì¸ ë°”ì´ëŸ¬ìŠ¤ë¥¼ ì—°êµ¬í•˜ë˜ ì—°êµ¬ì†Œì—ì„œ ë°”ì´ëŸ¬ìŠ¤ê°€ ìœ ì¶œë˜ì—ˆë‹¤. ë‹¤í–‰íˆ ë°”ì´ëŸ¬ìŠ¤ëŠ” ì•„ì§ í¼ì§€ì§€ ì•Šì•˜ê³ , ë°”ì´ëŸ¬ìŠ¤ì˜ í™•ì‚°ì„ ë§‰ê¸° ìœ„í•´ì„œ ì—°êµ¬ì†Œì— ë²½ì„ ì„¸ìš°ë ¤ê³  í•œë‹¤.</p>

<p>ì—°êµ¬ì†ŒëŠ” í¬ê¸°ê°€ NÃ—Mì¸ ì§ì‚¬ê°í˜•ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆìœ¼ë©°, ì§ì‚¬ê°í˜•ì€ 1Ã—1 í¬ê¸°ì˜ ì •ì‚¬ê°í˜•ìœ¼ë¡œ ë‚˜ëˆ„ì–´ì ¸ ìˆë‹¤. ì—°êµ¬ì†ŒëŠ” ë¹ˆ ì¹¸, ë²½ìœ¼ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, ë²½ì€ ì¹¸ í•˜ë‚˜ë¥¼ ê°€ë“ ì°¨ì§€í•œë‹¤. </p>

<p>ì¼ë¶€ ì¹¸ì€ ë°”ì´ëŸ¬ìŠ¤ê°€ ì¡´ì¬í•˜ë©°, ì´ ë°”ì´ëŸ¬ìŠ¤ëŠ” ìƒí•˜ì¢Œìš°ë¡œ ì¸ì ‘í•œ ë¹ˆ ì¹¸ìœ¼ë¡œ ëª¨ë‘ í¼ì ¸ë‚˜ê°ˆ ìˆ˜ ìˆë‹¤. ìƒˆë¡œ ì„¸ìš¸ ìˆ˜ ìˆëŠ” ë²½ì˜ ê°œìˆ˜ëŠ” 3ê°œì´ë©°, ê¼­ 3ê°œë¥¼ ì„¸ì›Œì•¼ í•œë‹¤.</p>

<p>ì˜ˆë¥¼ ë“¤ì–´, ì•„ë˜ì™€ ê°™ì´ ì—°êµ¬ì†Œê°€ ìƒê¸´ ê²½ìš°ë¥¼ ì‚´í´ë³´ì.</p>

<pre>2 0 0 0 1 1 0
0 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 0 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0</pre>

<p>ì´ë•Œ, 0ì€ ë¹ˆ ì¹¸, 1ì€ ë²½, 2ëŠ” ë°”ì´ëŸ¬ìŠ¤ê°€ ìˆëŠ” ê³³ì´ë‹¤. ì•„ë¬´ëŸ° ë²½ì„ ì„¸ìš°ì§€ ì•ŠëŠ”ë‹¤ë©´, ë°”ì´ëŸ¬ìŠ¤ëŠ” ëª¨ë“  ë¹ˆ ì¹¸ìœ¼ë¡œ í¼ì ¸ë‚˜ê°ˆ ìˆ˜ ìˆë‹¤.</p>

<p>2í–‰ 1ì—´, 1í–‰ 2ì—´, 4í–‰ 6ì—´ì— ë²½ì„ ì„¸ìš´ë‹¤ë©´ ì§€ë„ì˜ ëª¨ì–‘ì€ ì•„ë˜ì™€ ê°™ì•„ì§€ê²Œ ëœë‹¤.</p>

<pre>2 1 0 0 1 1 0
1 0 1 0 1 2 0
0 1 1 0 1 0 0
0 1 0 0 0 1 0
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0</pre>

<p>ë°”ì´ëŸ¬ìŠ¤ê°€ í¼ì§„ ë’¤ì˜ ëª¨ìŠµì€ ì•„ë˜ì™€ ê°™ì•„ì§„ë‹¤.</p>

<pre>2 1 0 0 1 1 2
1 0 1 0 1 2 2
0 1 1 0 1 2 2
0 1 0 0 0 1 2
0 0 0 0 0 1 1
0 1 0 0 0 0 0
0 1 0 0 0 0 0</pre>

<p>ë²½ì„ 3ê°œ ì„¸ìš´ ë’¤, ë°”ì´ëŸ¬ìŠ¤ê°€ í¼ì§ˆ ìˆ˜ ì—†ëŠ” ê³³ì„ ì•ˆì „ ì˜ì—­ì´ë¼ê³  í•œë‹¤. ìœ„ì˜ ì§€ë„ì—ì„œ ì•ˆì „ ì˜ì—­ì˜ í¬ê¸°ëŠ” 27ì´ë‹¤.</p>

<p>ì—°êµ¬ì†Œì˜ ì§€ë„ê°€ ì£¼ì–´ì¡Œì„ ë•Œ ì–»ì„ ìˆ˜ ìˆëŠ” ì•ˆì „ ì˜ì—­ í¬ê¸°ì˜ ìµœëŒ“ê°’ì„ êµ¬í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.</p>

### ì…ë ¥ 

 <p>ì²«ì§¸ ì¤„ì— ì§€ë„ì˜ ì„¸ë¡œ í¬ê¸° Nê³¼ ê°€ë¡œ í¬ê¸° Mì´ ì£¼ì–´ì§„ë‹¤. (3 â‰¤ N, M â‰¤ 8)</p>

<p>ë‘˜ì§¸ ì¤„ë¶€í„° Nê°œì˜ ì¤„ì— ì§€ë„ì˜ ëª¨ì–‘ì´ ì£¼ì–´ì§„ë‹¤. 0ì€ ë¹ˆ ì¹¸, 1ì€ ë²½, 2ëŠ” ë°”ì´ëŸ¬ìŠ¤ê°€ ìˆëŠ” ìœ„ì¹˜ì´ë‹¤. 2ì˜ ê°œìˆ˜ëŠ” 2ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ê³ , 10ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ì€ ìì—°ìˆ˜ì´ë‹¤.</p>

<p>ë¹ˆ ì¹¸ì˜ ê°œìˆ˜ëŠ” 3ê°œ ì´ìƒì´ë‹¤.</p>

### ì¶œë ¥ 

 <p>ì²«ì§¸ ì¤„ì— ì–»ì„ ìˆ˜ ìˆëŠ” ì•ˆì „ ì˜ì—­ì˜ ìµœëŒ€ í¬ê¸°ë¥¼ ì¶œë ¥í•œë‹¤.</p>



#  ğŸš€  ì˜¤ë‹µë…¸íŠ¸ 

```diff
+import java.io.*;
import java.util.*;
-import java.io.*;

public class Main {
+    static int N, M, map[][], answer = 0;
+    static List<int[]> emptyList = new ArrayList<>();
+    static List<int[]> virusList = new ArrayList<>();
+    static int[] dr = {1,-1,0,0};
+    static int[] dc = {0,0,1,-1};

-	static int N, M, map[][], answer = 0, wall;
-	static boolean visit[][], select[][]; 
-	static int dr[] = {1,-1,0,0};
-	static int dc[] = {0,0,1,-1};
-	
-	static StringBuilder sb = new StringBuilder();
-	public static void main(String[] args) throws IOException {
-		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
-		StringTokenizer st = new StringTokenizer(br.readLine());
-		
-		N = Integer.parseInt(st.nextToken());
-		M = Integer.parseInt(st.nextToken());
-		map = new int[N][M];
-				
-		for(int i=0 ; i < N ; i++) {
-			st = new StringTokenizer(br.readLine());
-			for(int j=0 ; j < M ; j++) {
-				int temp = Integer.parseInt(st.nextToken());
-				map[i][j] = temp;
-				if(temp == 1) wall++;
-			}
-		}
-		
-		DFS(0);
-		
-		System.out.println(answer);
-	}
-	
-	public static int BFS(int r, int c) {
-		Deque<int[]> q = new ArrayDeque<>();
-		q.offer(new int[] {r,c});
-		visit[r][c] = true;
-		int count = 0;
+    public static void main(String[] args) throws IOException {
+        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
+        StringTokenizer st = new StringTokenizer(br.readLine());
+        N = Integer.parseInt(st.nextToken());
+        M = Integer.parseInt(st.nextToken());
+        map = new int[N][M];

-		while(!q.isEmpty()) {
-			int[] cur = q.poll();
-			count++;
-			
-			for(int d=0 ; d < 4 ; d++) {
-				int nr = cur[0] + dr[d];
-				int nc = cur[1] + dc[d];
-				
-				if(!isIn(nr,nc) || visit[nr][nc] || map[nr][nc] != 0) continue;
-                visit[nr][nc] = true;
-                q.offer(new int[] {nr, nc});
-			}
-		}//end q while
-		
-		return count;
-	}
-	
-	public static int getSafeArea() {
-		visit = new boolean[N][M];
-		int sum = 0;
+        for (int i=0; i<N; i++) {
+            st = new StringTokenizer(br.readLine());
+            for (int j=0; j<M; j++) {
+                map[i][j] = Integer.parseInt(st.nextToken());
+                if (map[i][j] == 0) emptyList.add(new int[]{i,j});
+                else if (map[i][j] == 2) virusList.add(new int[]{i,j});
+            }
+        }

-		for(int i=0 ; i < N ; i++) {
-			for(int j=0 ; j < M ; j++) {
-				if(map[i][j] == 2) {
-					sum += BFS(i,j);
-				}
-			}
-		}
-		return N*M - sum - wall - 3;
-	}
-	
-	public static void DFS(int dep) {
-		if(dep == 3) {
-			answer = Math.max(answer, getSafeArea());
-			return;
-		}
-		
-		for(int i=0 ; i < N ; i++) {
-			for(int j=0 ; j < M ; j++) {
-				if(map[i][j] == 0) {
-					map[i][j] = 1;
-					DFS(dep+1);
-					map[i][j] = 0;
-				}
-				
-			}
-		}
-		
-	}
-	
-	public static boolean isIn(int r, int c) {
-		return 0 <= r && r < N && 0 <= c && c < M;		
-	}
+        comb(0, 0, new int[3][]);
+        System.out.println(answer);
+    }

+    static void comb(int start, int depth, int[][] walls) {
+        if (depth == 3) {
+            answer = Math.max(answer, getSafeArea(walls));
+            return;
+        }
+
+        for (int i = start; i < emptyList.size(); i++) {
+            walls[depth] = emptyList.get(i);
+            comb(i+1, depth+1, walls);
+        }
+    }
+
+    static int getSafeArea(int[][] walls) {
+        int[][] copy = new int[N][M];
+        for (int i=0; i < N; i++) copy[i] = map[i].clone();
+
+        for (int[] w : walls) copy[w[0]][w[1]] = 1;
+
+        Deque<int[]> q = new ArrayDeque<>();
+        for (int[] v : virusList) q.offer(v);
+
+        while (!q.isEmpty()) {
+            int[] cur = q.poll();
+            for (int d=0; d < 4; d++) {
+                int nr = cur[0] + dr[d];
+                int nc = cur[1] + dc[d];
+                if (!isIn(nr, nc)) continue;
+                if (copy[nr][nc] == 0) {
+                    copy[nr][nc] = 2;
+                    q.offer(new int[]{nr,nc});
+                }
+            }
+        }
+
+        int safe = 0;
+        for (int i=0; i < N; i++) {
+            for (int j=0; j < M; j++) {
+                if (copy[i][j] == 0) safe++;
+            }
+        }
+        return safe;
+    }
+    
+    static boolean isIn(int r, int c){
+        return r >= 0 && r < N && c >= 0 && c < M;
+    }
}

```

# ğŸ’» ì½”ë“œ ë¦¬ë·°




 ## ğŸ† ë©”ëª¨ 

ìˆ˜í–‰ ì‹œê°„ì´ ëŠë¦°ê²ƒ ê°™ì•„ì„œ, ë°°ì—´ì„ íƒìƒ‰í•˜ë©° ë¹ˆì¹¸ì´ë©´ ë²½ì„ ê³ ë¥´ëŠ” ë°©ì‹(ìˆœì—´) -> ë¹ˆì¹¸ì„ ë¯¸ë¦¬ ArrayListì— ì €ì¥í•´ë‘ê³  ë²½ì„ ê³ ë¥´ëŠ” ë°©ì‹ìœ¼ë¡œ ë³€ê²½(ì¡°í•©) 