# [Gold IV] ì´ë¶„ ê·¸ë˜í”„ - 1707 

[ë¬¸ì œ ë§í¬](https://www.acmicpc.net/problem/1707) 

### ë¶„ë¥˜

ê·¸ë˜í”„ ì´ë¡ , ê·¸ë˜í”„ íƒìƒ‰, ë„ˆë¹„ ìš°ì„  íƒìƒ‰, ê¹Šì´ ìš°ì„  íƒìƒ‰, ì´ë¶„ ê·¸ë˜í”„

### ë¬¸ì œ ì„¤ëª…

<p>ê·¸ë˜í”„ì˜ ì •ì ì˜ ì§‘í•©ì„ ë‘˜ë¡œ ë¶„í• í•˜ì—¬, ê° ì§‘í•©ì— ì†í•œ ì •ì ë¼ë¦¬ëŠ” ì„œë¡œ ì¸ì ‘í•˜ì§€ ì•Šë„ë¡ ë¶„í• í•  ìˆ˜ ìˆì„ ë•Œ, ê·¸ëŸ¬í•œ ê·¸ë˜í”„ë¥¼ íŠ¹ë³„íˆ ì´ë¶„ ê·¸ë˜í”„ (Bipartite Graph) ë¼ ë¶€ë¥¸ë‹¤.</p>

<p>ê·¸ë˜í”„ê°€ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì¡Œì„ ë•Œ, ì´ ê·¸ë˜í”„ê°€ ì´ë¶„ ê·¸ë˜í”„ì¸ì§€ ì•„ë‹Œì§€ íŒë³„í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ì‘ì„±í•˜ì‹œì˜¤.</p>

### ì…ë ¥ 

 <p>ì…ë ¥ì€ ì—¬ëŸ¬ ê°œì˜ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¡œ êµ¬ì„±ë˜ì–´ ìˆëŠ”ë°, ì²«ì§¸ ì¤„ì— í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ê°œìˆ˜ Kê°€ ì£¼ì–´ì§„ë‹¤. ê° í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ì˜ ì²«ì§¸ ì¤„ì—ëŠ” ê·¸ë˜í”„ì˜ ì •ì ì˜ ê°œìˆ˜ Vì™€ ê°„ì„ ì˜ ê°œìˆ˜ Eê°€ ë¹ˆ ì¹¸ì„ ì‚¬ì´ì— ë‘ê³  ìˆœì„œëŒ€ë¡œ ì£¼ì–´ì§„ë‹¤. ê° ì •ì ì—ëŠ” 1ë¶€í„° Vê¹Œì§€ ì°¨ë¡€ë¡œ ë²ˆí˜¸ê°€ ë¶™ì–´ ìˆë‹¤. ì´ì–´ì„œ ë‘˜ì§¸ ì¤„ë¶€í„° Eê°œì˜ ì¤„ì— ê±¸ì³ ê°„ì„ ì— ëŒ€í•œ ì •ë³´ê°€ ì£¼ì–´ì§€ëŠ”ë°, ê° ì¤„ì— ì¸ì ‘í•œ ë‘ ì •ì ì˜ ë²ˆí˜¸ u, v (u â‰  v)ê°€ ë¹ˆ ì¹¸ì„ ì‚¬ì´ì— ë‘ê³  ì£¼ì–´ì§„ë‹¤. </p>

### ì¶œë ¥ 

 <p>Kê°œì˜ ì¤„ì— ê±¸ì³ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§„ ê·¸ë˜í”„ê°€ ì´ë¶„ ê·¸ë˜í”„ì´ë©´ YES, ì•„ë‹ˆë©´ NOë¥¼ ìˆœì„œëŒ€ë¡œ ì¶œë ¥í•œë‹¤.</p>



#  ğŸš€  ì˜¤ë‹µë…¸íŠ¸ 

```diff
+import java.io.*;
import java.util.*;
-import java.io.*;

public class Main {
-    static boolean isNot;
-    static boolean[] isRed, visited;
+    static int T;
    static LinkedList<Integer>[] list;
+    static boolean[] visited, isBlue;
    public static void main(String[] args) throws IOException {
        BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));
-        
-        int T = Integer.parseInt(buffer.readLine());
+        T = Integer.parseInt(buffer.readLine());
        int t = 0;
-        while(T > t){
+
+        while(T>t){
            String[] input = buffer.readLine().split(" ");
            int n = Integer.parseInt(input[0]);
            int m = Integer.parseInt(input[1]);
-            
-            isRed = new boolean[n+1];
+            list = new LinkedList[n+1];
            visited = new boolean[n+1];
-            list = new LinkedList[n+1];
-            isNot = false;
-            
-            for(int i = 1; i <= n; i++){
+            isBlue = new boolean[n+1];
+
+            for (int i = 0; i <= n; i++) {
                list[i] = new LinkedList<>();
            }
-            
-            for(int i = 0; i < m; i++){        
+
+            for(int i = 0 ; i < m; i++){
                input = buffer.readLine().split(" ");
-                int end = Integer.parseInt(input[0]);
-                int start = Integer.parseInt(input[1]);
-                
+                int start = Integer.parseInt(input[0]);
+                int end = Integer.parseInt(input[1]);
+
                list[start].add(end);
                list[end].add(start);
            }
-            
-            for(int i = 1; i <=n; i++){
-                BFS(i);                                
+            boolean ans = false;
+            for(int i = 1 ; i <= n; i++){
+                if(visited[i]) continue;
+                ans = inspect(i, new boolean[n+1]);
+                if(!ans) break;
            }

-            
-            if(isNot) System.out.println("NO");
-            else System.out.println("YES");
+            if(ans) System.out.println("YES");
+            else System.out.println("NO");
            t++;
        }
    }
-    
-    public static void BFS(int start) {
-        LinkedList<Integer> queue = new LinkedList<>();
+
+    public static boolean inspect(int start, boolean[] color){
+        Queue<Integer> queue = new LinkedList<>();
+        visited[start] = true;
+        isBlue[start] = true;
        queue.offer(start);
-        visited[start] = true;
-        
-        while(!queue.isEmpty()) {
-            int now = queue.poll();
-            for(int node : list[now]){
-                if(!visited[node]){
-                    visited[node] = true;
-                    isRed[node] = !isRed[now];
-                    queue.offer(node);
-                } else if (isRed[node] == isRed[now]){
-                    isNot = true;
-                    return;
+
+        while(!queue.isEmpty()){
+            int cur = queue.poll();
+
+            for(int now : list[cur]){
+                if(visited[now]){
+                    if(isBlue[cur] == isBlue[now]) return false;
+                    else continue;
                }
+                visited[now] = true;
+                isBlue[now] = !isBlue[cur];
+                queue.offer(now);
            }
        }
+        return true;
    }
}

```

# ğŸ’» ì½”ë“œ ë¦¬ë·°




 ## ğŸ† ë©”ëª¨ 

ì´ë¶„ íƒìƒ‰ì—ì„œ visited ê°€ trueì¸ ì§€ì ì— ì§„ì… í•˜ê²Œ ë˜ë©´ ê·¸ë•ŒëŠ” curê³¼ nowì˜ ìƒ‰ìƒì„ ë¹„êµí•´ì„œ flase, cnotinue ì²˜ë¦¬ë¥¼ í•˜ë©´ ëœë‹¤.
ë°©ë¬¸í•˜ì§€ ì•Šì•˜ë‹¤ë©´ ìƒ‰ìƒì„ ë„£ì–´ì£¼ê³  queueì— ë„£ì–´ì£¼ì